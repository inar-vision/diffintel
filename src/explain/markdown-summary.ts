import { ExplainReport } from "./types";

/**
 * Render a compact markdown summary of the report for use as a PR comment.
 */
export function renderMarkdownSummary(report: ExplainReport): string {
  const { explanation, summary, files } = report;
  const parts: string[] = [];

  // Title
  parts.push(`### ${explanation.title}`);
  parts.push("");

  // Stats line
  parts.push(
    `**${summary.filesChanged} files** | **+${summary.additions}** added | **-${summary.deletions}** removed`,
  );
  parts.push("");

  // Impact
  if (explanation.impact.length > 0) {
    for (const item of explanation.impact) {
      parts.push(`> ${item}`);
    }
    parts.push("");
  }

  // Description or AST-only notice
  if (explanation.description) {
    parts.push(explanation.description);
    parts.push("");
  } else {
    parts.push("_Structural analysis only — set `ANTHROPIC_API_KEY` or `OPENAI_API_KEY` for AI-powered explanations._");
    parts.push("");

    // In AST-only mode, show structural changes as the primary content
    const structuralLines = renderStructuralTable(files);
    if (structuralLines) {
      parts.push(structuralLines);
      parts.push("");
    }
  }

  // Fixes
  if (explanation.fixes.length > 0) {
    parts.push("**What was fixed**");
    for (const fix of explanation.fixes) {
      parts.push(`- ${fix.description}`);
    }
    parts.push("");
  }

  // Risks
  if (explanation.risks.length > 0) {
    parts.push("**Things to watch**");
    for (const risk of explanation.risks) {
      parts.push(`- **${risk.level}** ${risk.description}`);
    }
    parts.push("");
  }

  // Blast radius
  if (report.dependencyGraph) {
    const { reverseDeps, secondRingDeps } = report.dependencyGraph;
    const hasDeps = reverseDeps.length > 0;

    parts.push("**Blast radius**");

    // Plain-language summary first
    if (explanation.blastRadiusSummary) {
      parts.push(explanation.blastRadiusSummary);
    } else if (!hasDeps) {
      parts.push("Changes are self-contained — no other files depend on the modified code.");
    } else {
      const uniqueReverse = [...new Set(reverseDeps.map((e) => e.from))].length;
      parts.push(`${uniqueReverse} file(s) directly depend on the changed code.`);
    }
    parts.push("");

    // Technical details in collapsible
    if (hasDeps) {
      parts.push("<details>");
      parts.push("<summary>Dependency details</summary>");
      parts.push("");
      const byTarget = new Map<string, string[]>();
      for (const edge of reverseDeps) {
        const list = byTarget.get(edge.to) || [];
        list.push(edge.from);
        byTarget.set(edge.to, list);
      }
      for (const [target, importers] of byTarget) {
        parts.push(`- \`${target}\` is imported by ${importers.length} file(s): ${importers.slice(0, 5).map((f) => `\`${f}\``).join(", ")}${importers.length > 5 ? ` and ${importers.length - 5} more` : ""}`);
      }
      if (secondRingDeps.length > 0) {
        const secondRingFiles = [...new Set(secondRingDeps.map((e) => e.from))];
        parts.push(`- ${secondRingFiles.length} additional file(s) indirectly affected`);
      }
      parts.push("");
      parts.push("</details>");
      parts.push("");
    }
  }

  // Per-file summaries (only when LLM explanations are present)
  if (explanation.fileExplanations.length > 0) {
    const fileLines: string[] = [];
    const maxFiles = 20;
    const shown = explanation.fileExplanations.slice(0, maxFiles);
    for (const fe of shown) {
      if (fe.summary) {
        fileLines.push(`- \`${fe.path}\` — ${fe.summary}`);
      }
    }
    if (fileLines.length > 0) {
      parts.push("**Changed files**");
      parts.push(...fileLines);
      if (explanation.fileExplanations.length > maxFiles) {
        parts.push(`- _...and ${explanation.fileExplanations.length - maxFiles} more_`);
      }
      parts.push("");
    }
  }

  // Footer
  parts.push("---");
  parts.push("_Generated by diffintel_");

  return parts.join("\n");
}

function renderStructuralTable(
  files: ExplainReport["files"],
): string | null {
  const rows: string[] = [];
  const maxFiles = 20;

  for (const file of files.slice(0, maxFiles)) {
    if (file.structuralChanges.length === 0) continue;

    const changes = file.structuralChanges
      .map((c) => `\`${c.action}\` ${c.name} (${c.type})`)
      .join(", ");
    rows.push(`| \`${file.path}\` | ${changes} |`);
  }

  if (rows.length === 0) return null;

  const header = "| File | Changes |\n|------|---------|";
  const table = [header, ...rows].join("\n");

  if (files.length > maxFiles) {
    return table + `\n\n_...and ${files.length - maxFiles} more files_`;
  }
  return table;
}
